package server;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import java.util.ArrayList;import java.util.Observable;import java.util.Observer;import common.*;import client.*;import ocsf.server.*;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer {  //Class variables *************************************************    /**   * The default port to listen on.   */  final public static int DEFAULT_PORT = 5555;  final public static String MESSAGE_PREFIX = "Serveur MSG>";  ObservableOriginatorServer server;  ChatIF serverUI;  //Constructors ****************************************************    /**   * Constructs an instance of the echo server.   *   * @param port The port number to connect on.   * @param server The instance of server.   */  public EchoServer(int port, ChatIF server)   {    this.server = new ObservableOriginatorServer(port);    this.server.addObserver(this);    serverUI = server;  }    //Instance methods ************************************************    /**   * This method handles any messages received from the client.   *   * @param msg The message received from the client.   * @param client The connection from which the message originated.   */  public void handleMessageFromClient    (Object msg, ConnectionToClient client)  {	  if(msg instanceof ArrayList){		  ArrayList tmp = (ArrayList)(msg);		  String command = (String)(tmp.get(0));		  if(command.equals("login")){			  if(client.getInfo("pseudo") == null){				  client.setInfo("pseudo",(String)(tmp.get(1)));				  this.sendToWelcomeMessage(MESSAGE_PREFIX+"Bonjour " + client.getInfo("pseudo"),MESSAGE_PREFIX+client.getInfo("pseudo") + " est connecté",client);				  serverUI.display("Nouveau client connecté : "+client.getInfo("pseudo"));			  }			  else{				  try {					client.sendToClient(MESSAGE_PREFIX+"Vous êtes déjà connecté.");				} catch (IOException e) {					e.printStackTrace();				}			  }		  }		  else if(command.equals("logoff")){			  try {				  String temp = (String)client.getInfo("pseudo");				client.sendToClient(MESSAGE_PREFIX+"A bientôt " + client.getInfo("pseudo"));				client.close();			} catch (IOException e) {				e.printStackTrace();			}		  }	  }	  else{		  if(client.getInfo("pseudo") != null){		    serverUI.display("Message reçu : " + msg + " de " + client.getInfo("pseudo"));		    server.sendToAllClients((String)(client.getInfo("pseudo")) + " : " + msg);		  }		  else{			  try {				client.sendToClient(MESSAGE_PREFIX+"Vous n'êtes pas connectés.");				client.close();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		  }	  }  }      /**   * This method overrides the one in the superclass.  Called   * when the server starts listening for connections.   */  protected void serverStarted()  {    serverUI.display("Le serveur écoute pour des connexions sur le port " + server.getPort());  }    /**   * This method overrides the one in the superclass.  Called   * when the server stops listening for connections.   */  protected void serverStopped()  {	  serverUI.display("Le serveur a arrêté d'écouter pour des connexions.");  }    protected void listeningException()  {	  serverUI.display("Le serveur arrête d'écouter pour des connexions sur le port " + server.getPort());  }    public Boolean isCommand(String mess){	  return mess.substring(0, 1).equals("#");  }    public void handleMessageFromServerUI(String message){	String[] tab = message.split(" ");	String command = tab[0];    if(isCommand(command)){		command = command.substring(1, command.length());		switch (command) {			case "quit":				server.sendToAllClients("#logoff");				System.exit(0);				break;			case "stop":				server.sendToAllClients("#logoff");				server.stopListening();				break;			case "close":				try {					server.close();				} catch (IOException e1) {					e1.printStackTrace();				}				break;			case "setport":				server.setPort(Integer.parseInt(tab[1]));				break;			case "start":				if(!server.isListening()){					try {						server.listen();					} catch (IOException e) {						e.printStackTrace();					}				}				break;			case "getport":		      serverUI.display(server.getPort()+"");				break;			case "kill":				Thread[] clientThreadList = server.getClientConnections();				for (int i = 0; i < clientThreadList.length; i++) {			        if(((ConnectionToClient)clientThreadList[i]).getInfo("pseudo").equals(tab[1])){			        	try {							((ConnectionToClient)clientThreadList[i]).sendToClient("#logoff");						} catch (IOException e) {							e.printStackTrace();						}			        }				}				break;		}    }	else{		if(server.isListening()) {			server.sendToAllClients(MESSAGE_PREFIX + message);		}		else {			serverUI.display("Le serveur n'a pas démarré ! ");		}	}  }      public void sendToWelcomeMessage(Object welcomeMessage,Object newclientMessage, ConnectionToClient client)  {    Thread[] clientThreadList = server.getClientConnections();    for (int i=0; i<clientThreadList.length; i++)    {    	if((ConnectionToClient)clientThreadList[i] != client){	      try	      {	        ((ConnectionToClient)clientThreadList[i]).sendToClient(newclientMessage);	      }	      catch (Exception ex) {}    	}    	else{  	      try  	      {  	        ((ConnectionToClient)clientThreadList[i]).sendToClient(welcomeMessage);  	      }  	      catch (Exception ex) {}    	}    }  }    protected void clientConnected(ConnectionToClient client) {	  serverUI.display("Nouveau client ! ");  }    synchronized protected void clientDisconnected(ConnectionToClient client) {	  serverUI.display("Déconnexion de " + client.getInfo("pseudo"));	  this.sendToWelcomeMessage(MESSAGE_PREFIX+"A bientôt " + client.getInfo("pseudo"),MESSAGE_PREFIX+client.getInfo("pseudo") + " s'est déconnecté.",client);  }    synchronized protected void clientException(		    ConnectionToClient client, Throwable exception) {	  serverUI.display("Déconnexion !");  }  protected void serverClosed(){	serverUI.display("Serveur fermé !");}    //Class methods ***************************************************@Overridepublic void update(Observable o, Object arg) {	OriginatorMessage argu = (OriginatorMessage)arg;	if(argu.getMessage() instanceof ArrayList){		handleMessageFromClient(argu.getMessage(), argu.getOriginator());	}	else{		String argument = argu.getMessage().toString();			if(argument.equals(ObservableServer.SERVER_CLOSED)){			serverClosed();		}		else if(argument.equals(ObservableServer.SERVER_STARTED)){			serverStarted();		}		else if(argument.equals(ObservableServer.SERVER_STOPPED)){			serverStopped();		}		else if(argument.equals(ObservableServer.CLIENT_CONNECTED)){			clientConnected(argu.getOriginator());		}		else if(argument.equals(ObservableServer.CLIENT_DISCONNECTED)){			clientDisconnected(argu.getOriginator());		}		else if(arg instanceof OriginatorMessage){			OriginatorMessage org = (OriginatorMessage)(arg);			String mess = (String) (org.getMessage());			if( mess.startsWith(ObservableOriginatorServer.LISTENING_EXCEPTION)){				listeningException();			}			else if( mess.startsWith(ObservableOriginatorServer.CLIENT_EXCEPTION)){				Exception ex = new Exception(mess.replace(ObservableOriginatorServer.LISTENING_EXCEPTION,""));				clientException(org.getOriginator(), ex);			}			else if( mess.startsWith(ObservableOriginatorServer.CLIENT_DISCONNECTED)){				clientDisconnected(org.getOriginator());			}			else{				handleMessageFromClient(argument,argu.getOriginator());			}		}	}}}//End of EchoServer class